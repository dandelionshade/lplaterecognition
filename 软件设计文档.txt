å¤©æ´¥ä»çˆ±å­¦é™¢æ™ºèƒ½è½¦ç‰Œè¯†åˆ«ç³»ç»Ÿ
è½¯ä»¶è®¾è®¡æ–‡æ¡£

================================================================================
1. å¼•è¨€
================================================================================

1.1. é¡¹ç›®æ¦‚è¿°
æœ¬æ–‡æ¡£æ—¨åœ¨è¯¦ç»†é˜è¿°â€œå¤©æ´¥ä»çˆ±å­¦é™¢æ™ºèƒ½è½¦ç‰Œè¯†åˆ«ç³»ç»Ÿâ€çš„è®¾è®¡æ–¹æ¡ˆã€‚è¯¥ç³»ç»Ÿæ˜¯ä¸€ä¸ªåŸºäºWebçš„åº”ç”¨ç¨‹åºï¼Œæ—¨åœ¨æä¾›ä¸€ä¸ªé›†æˆåŒ–ã€æ™ºèƒ½åŒ–å’Œç”¨æˆ·å‹å¥½çš„è½¦ç‰Œè¯†åˆ«ä¸å›¾åƒåˆ†æå¹³å°ã€‚ç³»ç»Ÿåç«¯é‡‡ç”¨Python Flaskæ¡†æ¶ï¼Œå‰ç«¯ä½¿ç”¨åŸç”ŸHTML/CSS/JavaScriptæ„å»ºï¼Œå¹¶é›†æˆäº†åŒ…æ‹¬Google Geminiã€HyperLPR3ã€PaddleOCRåœ¨å†…çš„å¤šç§å…ˆè¿›AIå¼•æ“ã€‚

1.2. è®¾è®¡ç›®æ ‡
- **æ¨¡å—åŒ–ä¸å¯æ‰©å±•æ€§**ï¼šæ„å»ºæ¾è€¦åˆçš„ç³»ç»Ÿæ¶æ„ï¼Œæ–¹ä¾¿æœªæ¥æ–°å¢åŠŸèƒ½æˆ–æ›¿æ¢æŠ€æœ¯ç»„ä»¶ã€‚
- **é«˜æ€§èƒ½ä¸å®æ—¶æ€§**ï¼šä¼˜åŒ–APIå“åº”æ—¶é—´ï¼Œç¡®ä¿å›¾åƒå¤„ç†å’ŒAIåˆ†æçš„æ•ˆç‡ï¼Œæä¾›æµç•…çš„ç”¨æˆ·ä½“éªŒã€‚
- **å®‰å…¨æ€§**ï¼šå®ç°å¯é çš„ç”¨æˆ·è®¤è¯å’Œæˆæƒæœºåˆ¶ï¼Œä¿æŠ¤ç³»ç»Ÿèµ„æºå’Œæ•°æ®ã€‚
- **ç”¨æˆ·å‹å¥½æ€§**ï¼šè®¾è®¡ç›´è§‚ã€ç®€æ´ã€å“åº”å¼çš„ç”¨æˆ·ç•Œé¢ï¼Œé™ä½ç”¨æˆ·å­¦ä¹ æˆæœ¬ã€‚
- **å¥å£®æ€§ä¸å®¹é”™æ€§**ï¼šå®ç°å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•æœºåˆ¶ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹ç¨³å®šè¿è¡Œã€‚

1.3. èŒƒå›´
æœ¬æ–‡æ¡£è¦†ç›–äº†ç³»ç»Ÿçš„æ€»ä½“æ¶æ„è®¾è®¡ã€æ¨¡å—åŠŸèƒ½è®¾è®¡ã€æ•°æ®åº“è®¾è®¡ã€æ¥å£è®¾è®¡å’Œç•Œé¢è®¾è®¡ã€‚

================================================================================
2. ç³»ç»Ÿæ€»ä½“æ¶æ„
================================================================================

æœ¬ç³»ç»Ÿé‡‡ç”¨ç»å…¸çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨ï¼ˆC/Sï¼‰æ¶æ„ã€‚

2.1. æŠ€æœ¯æ ˆ
- **åç«¯**ï¼š
  - **è¯­è¨€**: Python 3.9+
  - **Webæ¡†æ¶**: Flask
  - **AIå¼•æ“**:
    - Google Gemini (å¤šæ¨¡æ€åˆ†æ)
    - HyperLPR3 (ä¸“ä¸šè½¦ç‰Œè¯†åˆ«)
    - PaddleOCR (é€šç”¨OCR)
    - Tesseract (å¤‡ç”¨OCR)
    - EasyOCR (å¤‡ç”¨OCR)
  - **å›¾åƒå¤„ç†**: OpenCV, Pillow
  - **éƒ¨ç½²**: Gunicorn + Nginx (ç”Ÿäº§ç¯å¢ƒ)

- **å‰ç«¯**ï¼š
  - **è¯­è¨€**: HTML5, CSS3, JavaScript (ES6+)
  - **æ ¸å¿ƒæŠ€æœ¯**: Fetch API (å¼‚æ­¥é€šä¿¡), DOMæ“ä½œ
  - **UI/UX**: å“åº”å¼è®¾è®¡ï¼Œæ”¯æŒæ¡Œé¢å’Œç§»åŠ¨ç«¯

2.2. æ¶æ„å›¾
```
+----------------------+       +-------------------------+       +-----------------------+
|      Web Browser     |       |      Web Server (Flask) |       |      AI Services      |
| (HTML/CSS/JS)        |       |                         |       |                       |
+----------------------+       +-------------------------+       +-----------------------+
| - ç”¨æˆ·ç•Œé¢æ¸²æŸ“       |       | - è·¯ç”±ä¸è§†å›¾å¤„ç†        |       | - Google Gemini API   |
| - ç”¨æˆ·è¾“å…¥å¤„ç†       |       | - ç”¨æˆ·è®¤è¯ä¸ä¼šè¯ç®¡ç†    |       | - HyperLPR3 Engine    |
| - APIå¼‚æ­¥è¯·æ±‚        |------>| - é™æ€æ–‡ä»¶æœåŠ¡          |------>| - PaddleOCR Engine    |
| - ç»“æœåŠ¨æ€å±•ç¤º       |       | - ä¸šåŠ¡é€»è¾‘å¤„ç†          |       | - Tesseract Engine    |
+----------------------+       | - AIå¼•æ“è°ƒåº¦            |       | - EasyOCR Engine      |
        ^                      | - å›¾åƒå¤„ç† (OpenCV)     |       +-----------------------+
        |                      +-------------------------+
        |                              |
        +------------------------------+
               (HTTP/HTTPS)
```

================================================================================
3. æ¨¡å—è®¾è®¡
================================================================================

ç³»ç»Ÿä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒæ¨¡å—ï¼š

3.1. ç”¨æˆ·è®¤è¯æ¨¡å—
- **åŠŸèƒ½**: æä¾›ç”¨æˆ·ç™»å½•ã€ç™»å‡ºåŠä¼šè¯ç®¡ç†åŠŸèƒ½ã€‚
- **å®ç°**:
  - ä½¿ç”¨Flask sessionè¿›è¡Œä¼šè¯ç®¡ç†ã€‚
  - å¯†ç é‡‡ç”¨å“ˆå¸ŒåŠ å¯†å­˜å‚¨ï¼ˆæœªæ¥å¢å¼ºé¡¹ï¼‰ã€‚
  - æä¾›`@login_required`è£…é¥°å™¨ï¼Œä¿æŠ¤éœ€è¦æˆæƒçš„è·¯ç”±ã€‚

**æ ¸å¿ƒä»£ç å®ç°**ï¼š

```python
# ç”¨æˆ·è®¤è¯è£…é¥°å™¨å®ç°
from functools import wraps
from flask import session, redirect, url_for

def login_required(f):
    """ç™»å½•è®¤è¯è£…é¥°å™¨"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'logged_in' not in session:  # æ£€æŸ¥ç™»å½•çŠ¶æ€
            return redirect(url_for('login'))  # æœªç™»å½•é‡å®šå‘
        return f(*args, **kwargs)  # å·²ç™»å½•ç»§ç»­æ‰§è¡Œ
    return decorated_function

# ç®¡ç†å‘˜è´¦æˆ·é…ç½®
import hashlib
ADMIN_USERNAME = 'admin'  # ç®¡ç†å‘˜ç”¨æˆ·å
ADMIN_PASSWORD_HASH = hashlib.sha256('admin'.encode()).hexdigest()  # å¯†ç å“ˆå¸Œ

# ç™»å½•éªŒè¯é€»è¾‘
@app.route("/login", methods=["GET", "POST"])
def login():
    """ç®¡ç†å‘˜ç™»å½•å¤„ç†"""
    if request.method == "POST":
        username = request.form.get('username')  # è·å–ç”¨æˆ·å
        password = request.form.get('password')  # è·å–å¯†ç 
        
        # éªŒè¯å‡­æ®
        if username == ADMIN_USERNAME and \
           hashlib.sha256(password.encode()).hexdigest() == ADMIN_PASSWORD_HASH:
            session['logged_in'] = True  # è®¾ç½®ç™»å½•çŠ¶æ€
            session['username'] = username  # ä¿å­˜ç”¨æˆ·ä¿¡æ¯
            return redirect(url_for('admin_dashboard'))  # è·³è½¬åˆ°ç®¡ç†é¢æ¿
        else:
            return render_template_string(LOGIN_TEMPLATE, error="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
    
    return render_template_string(LOGIN_TEMPLATE)  # æ˜¾ç¤ºç™»å½•é¡µé¢

# å®‰å…¨ç™»å‡º
@app.route("/logout")
def logout():
    """ç”¨æˆ·ç™»å‡º"""
    session.clear()  # æ¸…é™¤æ‰€æœ‰ä¼šè¯æ•°æ®
    return redirect(url_for('login'))  # é‡å®šå‘åˆ°ç™»å½•é¡µ
```

- **ä¸»è¦æ¥å£**: `/login`, `/logout`, `/admin`

3.2. Webç•Œé¢æ¨¡å—
- **åŠŸèƒ½**: æä¾›ç”¨æˆ·ä¸ç³»ç»Ÿäº¤äº’çš„å›¾å½¢ç•Œé¢ã€‚
- **å®ç°**:
  - **ç™»å½•é¡µ (`/login`)**: æä¾›ç™»å½•è¡¨å•ã€‚
  - **ä¸»é¡µ (`/home`)**: ç³»ç»ŸåŠŸèƒ½ä»‹ç»å’Œå¯¼èˆªã€‚
  - **OCRè¯†åˆ«é¡µ (`/ocr`)**: é›†æˆGeminiåˆ†æã€é€šç”¨OCRã€ä¸“ä¸šè½¦ç‰Œè¯†åˆ«å’Œå›¾åƒå¤„ç†å››å¤§åŠŸèƒ½åŒºï¼Œé‡‡ç”¨æ ‡ç­¾é¡µè®¾è®¡ã€‚
  - **ç®¡ç†å‘˜æ§åˆ¶å° (`/admin`)**ï¼šæä¾›ç³»ç»Ÿç®¡ç†å…¥å£ã€‚

**æ ¸å¿ƒä»£ç å®ç°**ï¼š

```python
# é¡µé¢è·¯ç”±å®šä¹‰
@app.route("/")
@login_required
def index():
    """æ ¹è·¯å¾„é‡å®šå‘"""
    return redirect(url_for('home'))  # é‡å®šå‘åˆ°ä¸»é¡µ

@app.route("/home")
@login_required
def home():
    """ç³»ç»Ÿä¸»é¡µ"""
    response = send_from_directory('web', 'home.html')  # æä¾›é™æ€HTMLæ–‡ä»¶
    # æ·»åŠ å®‰å…¨å“åº”å¤´
    response.headers['X-Frame-Options'] = 'DENY'  # é˜²æ­¢é¡µé¢è¢«åµŒå…¥iframe
    response.headers['X-Content-Type-Options'] = 'nosniff'  # é˜²æ­¢MIMEç±»å‹å—…æ¢
    response.headers['Referrer-Policy'] = 'no-referrer'  # è®¾ç½®å¼•ç”¨ç­–ç•¥
    return response

@app.route("/ocr")
@login_required
def ocr_page():
    """OCRåŠŸèƒ½é¡µé¢"""
    response = send_from_directory('web', 'ocr.html')  # æä¾›OCRé¡µé¢
    # æ·»åŠ ç›¸åŒçš„å®‰å…¨å¤´
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['Referrer-Policy'] = 'no-referrer'
    return response

@app.route("/admin")
@login_required
def admin_dashboard():
    """ç®¡ç†å‘˜ä»ªè¡¨ç›˜"""
    return render_template_string(ADMIN_DASHBOARD_TEMPLATE, username=session.get('username'))
```

**å‰ç«¯æ ‡ç­¾é¡µç»“æ„**ï¼š

```html
<!-- æ ‡ç­¾å¯¼èˆªç³»ç»Ÿ -->
<nav class="tab-nav">
  <button class="tab-btn active" data-tab="gemini">
    <i class="fas fa-brain"></i> Gemini AIåˆ†æ  <!-- AIå¤šæ¨¡æ€åˆ†æ -->
  </button>
  <button class="tab-btn" data-tab="ocr">
    <i class="fas fa-font"></i> é€šç”¨OCRè¯†åˆ«    <!-- æ–‡å­—è¯†åˆ« -->
  </button>
  <button class="tab-btn" data-tab="plate">
    <i class="fas fa-car"></i> ä¸“ä¸šè½¦ç‰Œè¯†åˆ«    <!-- è½¦ç‰Œä¸“ç”¨è¯†åˆ« -->
  </button>
  <button class="tab-btn" data-tab="process">
    <i class="fas fa-cogs"></i> å›¾åƒå¤„ç†      <!-- OpenCVå›¾åƒå¤„ç† -->
  </button>
</nav>

<!-- åŠŸèƒ½å†…å®¹åŒºåŸŸ -->
<main class="tab-container">
  <!-- é€šç”¨OCRè¯†åˆ«æ ‡ç­¾é¡µ -->
  <div id="ocr" class="tab-content">
    <div class="panel">
      <h3><i class="fas fa-font"></i> é€šç”¨OCRæ–‡å­—è¯†åˆ«</h3>
      
      <!-- å›¾ç‰‡ä¸Šä¼ åŒº -->
      <div class="image-input-section">
        <div class="upload-section">
          <label for="ocr-upload" class="upload-btn">
            <i class="fas fa-upload"></i> ä¸Šä¼ å›¾ç‰‡
          </label>
          <input type="file" id="ocr-upload" accept="image/*" style="display: none;">
          <div id="ocr-preview" class="image-preview"></div>  <!-- å›¾ç‰‡é¢„è§ˆ -->
        </div>
      </div>
      
      <!-- å¼•æ“é€‰æ‹© -->
      <div class="engine-selection">
        <label>é€‰æ‹© OCR å¼•æ“ï¼š</label>
        <div class="engine-options">
          <label class="engine-option">
            <input type="radio" name="ocr-engine" value="paddleocr" checked>
            <span>PaddleOCR</span>  <!-- ç™¾åº¦é«˜ç²¾åº¦OCR -->
          </label>
          <label class="engine-option">
            <input type="radio" name="ocr-engine" value="tesseract">
            <span>Tesseract</span>  <!-- ä¼ ç»Ÿå¼€æºOCR -->
          </label>
        </div>
      </div>
      
      <!-- æ“ä½œæŒ‰é’® -->
      <div class="action-section">
        <button id="ocr-recognize" class="action-btn" disabled>
          <i class="fas fa-search"></i> å¼€å§‹è¯†åˆ«
        </button>
      </div>
      
      <!-- ç»“æœæ˜¾ç¤º -->
      <div class="result-section">
        <h4>è¯†åˆ«ç»“æœï¼š</h4>
        <div id="ocr-result" class="result-box">è¯·å…ˆä¸Šä¼ å›¾ç‰‡</div>
      </div>
    </div>
  </div>
</main>
```

- **æŠ€æœ¯**: HTMLæ¨¡æ¿ï¼ŒCSSå®ç°æ ·å¼ï¼ŒJavaScriptè´Ÿè´£äº¤äº’é€»è¾‘ã€‚

3.3. å›¾åƒè¯†åˆ«APIæ¨¡å— (`/api/ocr-simple`)
- **åŠŸèƒ½**: æ¥æ”¶å›¾åƒæ•°æ®ï¼Œè°ƒç”¨åç«¯AIå¼•æ“è¿›è¡Œè¯†åˆ«ï¼Œå¹¶è¿”å›ç»“æœã€‚

**æ ¸å¿ƒä»£ç å®ç°**ï¼š

```python
@app.route("/api/ocr-simple", methods=["POST"])
def ocr_simple_api():
    """å¢å¼ºçš„OCRè¯†åˆ«API - å¤šå¼•æ“æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ"""
    try:
        # 1. è¯·æ±‚æ•°æ®è§£æ
        data = request.get_json()  # è§£æJSONè¯·æ±‚
        image_base64 = data.get('image')  # è·å–base64å›¾åƒ
        engine = data.get('engine', 'auto')  # è·å–å¼•æ“é€‰æ‹©ï¼Œé»˜è®¤è‡ªåŠ¨
        
        if not image_base64:  # éªŒè¯å›¾åƒæ•°æ®
            return jsonify({"error": "æ²¡æœ‰æä¾›å›¾åƒæ•°æ®"}), 400
        
        # 2. å›¾åƒæ•°æ®è½¬æ¢
        image_data = base64.b64decode(image_base64)  # base64è§£ç 
        nparr = np.frombuffer(image_data, np.uint8)  # è½¬æ¢ä¸ºnumpyæ•°ç»„
        image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)  # è§£ç ä¸ºOpenCVå›¾åƒ
        
        if image is None:  # éªŒè¯å›¾åƒæœ‰æ•ˆæ€§
            return jsonify({"error": "å›¾åƒæ ¼å¼é”™è¯¯"}), 400
        
        # 3. å›¾åƒè´¨é‡åˆ†æ
        image_quality = analyze_image_quality(image)  # åˆ†æå›¾åƒè´¨é‡
        print(f"ğŸ“Š å›¾åƒè´¨é‡è¯„åˆ†: {image_quality['quality_score']}/100")
        
        # 4. æ™ºèƒ½å¼•æ“é€‰æ‹©ç­–ç•¥
        def get_engines_priority(requested_engine):
            """æ ¹æ®è¯·æ±‚çš„å¼•æ“è¿”å›ä¼˜å…ˆçº§é˜Ÿåˆ—"""
            if requested_engine == 'auto':  # è‡ªåŠ¨æ¨¡å¼ - æ™ºèƒ½é€‰æ‹©æœ€ä½³é¡ºåº
                return ['hyperlpr3', 'paddleocr', 'easyocr', 'tesseract', 'fallback']
            elif requested_engine == 'hyperlpr3':  # è½¦ç‰Œè¯†åˆ«ä¼˜å…ˆ
                return ['hyperlpr3', 'paddleocr', 'easyocr', 'tesseract', 'fallback']
            elif requested_engine == 'paddleocr':  # é€šç”¨OCRä¼˜å…ˆ
                return ['paddleocr', 'easyocr', 'tesseract', 'hyperlpr3', 'fallback']
            else:  # Tesseractç­‰å…¶ä»–å¼•æ“
                return ['tesseract', 'paddleocr', 'easyocr', 'hyperlpr3', 'fallback']
        
        engines_to_try = get_engines_priority(engine)  # è·å–å¼•æ“è°ƒç”¨é¡ºåº
        best_result = None  # å­˜å‚¨æœ€ä½³è¯†åˆ«ç»“æœ
        best_confidence = 0  # å­˜å‚¨æœ€é«˜ç½®ä¿¡åº¦
        
        # 5. å¤šå¼•æ“å¾ªç¯è¯†åˆ«
        for engine_name in engines_to_try:
            try:
                engine_result = None
                
                # HyperLPR3ä¸“ä¸šè½¦ç‰Œè¯†åˆ«å¼•æ“
                if engine_name == 'hyperlpr3' and HYPERLPR_AVAILABLE and 'hyperlpr3' in ocr_engines:
                    catcher = ocr_engines['hyperlpr3']  # è·å–è½¦ç‰Œè¯†åˆ«å™¨
                    
                    # å›¾åƒé¢„å¤„ç†å¢å¼º
                    enhanced_image = enhance_image_for_ocr(image, 'plate')  # è½¦ç‰Œä¸“ç”¨å¢å¼º
                    rgb_image = cv2.cvtColor(enhanced_image, cv2.COLOR_BGR2RGB)  # BGRè½¬RGB
                    
                    plates = catcher(rgb_image)  # æ‰§è¡Œè½¦ç‰Œè¯†åˆ«
                    
                    if plates and len(plates) > 0:
                        plate_results = []  # æ­£å¸¸ç½®ä¿¡åº¦ç»“æœ
                        low_confidence_plates = []  # ä½ç½®ä¿¡åº¦å€™é€‰
                        
                        for plate in plates:
                            if plate and len(plate) >= 2:
                                plate_no = str(plate[0])  # è½¦ç‰Œå·ç 
                                confidence = float(plate[1])  # ç½®ä¿¡åº¦
                                plate_info = {
                                    'text': plate_no,
                                    'confidence': confidence,
                                    'bbox': plate[2] if len(plate) > 2 else None  # è¾¹ç•Œæ¡†
                                }
                                
                                if plate_no and confidence > 0.1:  # æ­£å¸¸ç½®ä¿¡åº¦é˜ˆå€¼
                                    plate_results.append(plate_info)
                                elif plate_no and confidence > 0.05:  # ä½ç½®ä¿¡åº¦é˜ˆå€¼
                                    low_confidence_plates.append(plate_info)
                        
                        # å¤„ç†è¯†åˆ«ç»“æœ
                        if plate_results:  # æœ‰æ­£å¸¸ç½®ä¿¡åº¦ç»“æœ
                            best_plate = max(plate_results, key=lambda x: x['confidence'])
                            engine_result = {
                                'engine': 'hyperlpr3',
                                'text': best_plate['text'],
                                'confidence': best_plate['confidence'],
                                'plates': plate_results,
                                'low_confidence_plates': low_confidence_plates,
                                'engine_available': True,
                                'enhanced_processing': True
                            }
                            print(f"âœ… HyperLPR3è¯†åˆ«æˆåŠŸ: {best_plate['text']} (ç½®ä¿¡åº¦: {best_plate['confidence']:.2f})")
                
                # PaddleOCRé€šç”¨æ–‡å­—è¯†åˆ«å¼•æ“
                elif engine_name == 'paddleocr' and PADDLEOCR_AVAILABLE and 'paddleocr' in ocr_engines:
                    paddle_results = ocr_engines['paddleocr'].ocr(image)  # æ‰§è¡ŒOCRè¯†åˆ«
                    
                    if paddle_results and paddle_results[0]:
                        texts = []  # è¯†åˆ«çš„æ–‡æœ¬åˆ—è¡¨
                        confidences = []  # å¯¹åº”çš„ç½®ä¿¡åº¦åˆ—è¡¨
                        
                        for line in paddle_results[0]:  # éå†æ¯è¡Œè¯†åˆ«ç»“æœ
                            if line and len(line) >= 2 and line[1][1] > 0.3:  # ç½®ä¿¡åº¦ç­›é€‰
                                text = line[1][0].strip()  # æå–æ–‡æœ¬å†…å®¹
                                conf = line[1][1]  # æå–ç½®ä¿¡åº¦
                                texts.append(text)
                                confidences.append(conf)
                        
                        if texts:
                            full_text = ''.join(texts).replace(' ', '')  # åˆå¹¶æ–‡æœ¬
                            avg_confidence = sum(confidences) / len(confidences)  # å¹³å‡ç½®ä¿¡åº¦
                            
                            # è½¦ç‰Œæ ¼å¼åŒ¹é…æ£€æŸ¥ - æ™ºèƒ½åŠ åˆ†æœºåˆ¶
                            import re
                            plate_pattern = r'[äº¬æ´¥æ²ªæ¸å†€è±«äº‘è¾½é»‘æ¹˜çš–é²æ–°è‹æµ™èµ£é„‚æ¡‚ç”˜æ™‹è’™é™•å‰é—½è´µç²¤é’è—å·å®ç¼ä½¿é¢†][A-Z][A-Z0-9]{4,5}'
                            if re.search(plate_pattern, full_text):  # åŒ¹é…ä¸­å›½è½¦ç‰Œæ ¼å¼
                                avg_confidence = min(avg_confidence + 0.3, 1.0)  # æ ¼å¼åŒ¹é…å¥–åŠ±
                            
                            engine_result = {
                                'engine': 'paddleocr',
                                'text': full_text,
                                'confidence': avg_confidence,
                                'texts': texts,
                                'individual_confidences': confidences,
                                'engine_available': True,
                                'plate_format_matched': bool(re.search(plate_pattern, full_text))
                            }
                            print(f"âœ… PaddleOCRè¯†åˆ«æˆåŠŸ: {full_text} (ç½®ä¿¡åº¦: {avg_confidence:.2f})")
                
                # 6. ç»“æœè¯„ä¼°ä¸ä¼˜é€‰
                if engine_result and engine_result.get('confidence', 0) > best_confidence:
                    best_result = engine_result  # æ›´æ–°æœ€ä½³ç»“æœ
                    best_confidence = engine_result['confidence']  # æ›´æ–°æœ€é«˜ç½®ä¿¡åº¦
                    
                    # é«˜ç½®ä¿¡åº¦æ—©åœæœºåˆ¶ - æå‡å“åº”é€Ÿåº¦
                    if best_confidence > 0.7:
                        print(f"ğŸ¯ é«˜ç½®ä¿¡åº¦ç»“æœï¼Œæå‰è¿”å›: {engine_result['text']}")
                        break  # è·³å‡ºå¾ªç¯ï¼Œç›´æ¥è¿”å›ç»“æœ
                        
            except Exception as e:
                print(f"ğŸ’¥ å¼•æ“ {engine_name} è¿è¡Œå¤±è´¥: {e}")
                continue  # ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªå¼•æ“
        
        # 7. ç»Ÿä¸€ç»“æœè¿”å›
        if best_result and best_result.get('text'):
            response_data = {
                "success": True,
                "engine": best_result['engine'],
                "text": best_result['text'],
                "confidence": best_result['confidence'],
                "results": best_result,
                "image_quality": image_quality,
                "message": f"ä½¿ç”¨ {best_result['engine']} å¼•æ“è¯†åˆ«æˆåŠŸ"
            }
            
            # æ·»åŠ ä½ç½®ä¿¡åº¦è­¦å‘Š
            if best_result.get('is_low_confidence'):
                response_data['warning'] = "è¯†åˆ«ç½®ä¿¡åº¦è¾ƒä½ï¼Œå»ºè®®éªŒè¯ç»“æœå‡†ç¡®æ€§"
            
            return jsonify(response_data)
        else:
            # æ‰€æœ‰å¼•æ“éƒ½å¤±è´¥çš„æƒ…å†µ
            return jsonify({
                "success": False,
                "engine": "fallback",
                "error": "æ‰€æœ‰OCRå¼•æ“è¯†åˆ«å¤±è´¥",
                "image_quality": image_quality,
                "suggestion": "å»ºè®®æ£€æŸ¥å›¾ç‰‡è´¨é‡ã€è°ƒæ•´å…‰ç…§æ¡ä»¶æˆ–æ›´æ¢å›¾ç‰‡æ ¼å¼"
            })
            
    except Exception as e:
        print(f"ğŸ’¥ APIç³»ç»Ÿé”™è¯¯: {e}")
        return jsonify({
            "success": False,
            "engine": "system",
            "error": f"ç³»ç»Ÿé”™è¯¯: {str(e)}"
        }), 500
```

- **æ ¸å¿ƒé€»è¾‘**:
  1. **æ™ºèƒ½å¼•æ“è°ƒåº¦**: æ ¹æ®ç”¨æˆ·è¯·æ±‚æˆ–`auto`æ¨¡å¼ï¼Œç¡®å®š`['hyperlpr3', 'paddleocr', 'easyocr', 'tesseract', 'fallback']`çš„ä¼˜å…ˆçº§è°ƒç”¨é¡ºåºã€‚
  2. **å›¾åƒé¢„å¤„ç†**: å¯¹è¾“å…¥å›¾åƒè¿›è¡Œè´¨é‡åˆ†æå’Œå¢å¼ºï¼Œæé«˜è¯†åˆ«ç‡ã€‚
  3. **å¤šå¼•æ“å¾ªç¯**: æŒ‰ä¼˜å…ˆçº§ä¾æ¬¡å°è¯•ä¸åŒå¼•æ“ï¼Œç›´åˆ°è·å¾—é«˜ç½®ä¿¡åº¦ç»“æœæˆ–æ‰€æœ‰å¼•æ“å°è¯•å®Œæ¯•ã€‚
  4. **ç»“æœèåˆä¸è¯„ä¼°**: é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„ç»“æœä½œä¸ºæœ€ä½³ç»“æœã€‚å¯¹ä½ç½®ä¿¡åº¦ç»“æœè¿›è¡Œç‰¹æ®Šæ ‡è®°ã€‚
  5. **ç»Ÿä¸€æ ¼å¼è¿”å›**: å°†ä¸åŒå¼•æ“çš„è¿”å›ç»“æœå°è£…æˆç»Ÿä¸€çš„JSONæ ¼å¼ã€‚
- **å®¹é”™æœºåˆ¶**: åŒ…å«å¯¹å•ä¸ªå¼•æ“å¤±è´¥çš„`try-except`å¤„ç†ï¼Œç¡®ä¿æŸä¸ªå¼•æ“çš„æ•…éšœä¸å½±å“æ•´ä½“æµç¨‹ã€‚

3.4. å›¾åƒå¤„ç†æ¨¡å—
- **åŠŸèƒ½**: æä¾›ä¸€ç³»åˆ—åŸºç¡€å›¾åƒå¤„ç†åŠŸèƒ½ã€‚

**æ ¸å¿ƒä»£ç å®ç°**ï¼š

```python
# å›¾åƒå¤„ç†APIç«¯ç‚¹
@app.route("/api/process-image", methods=["POST"])
@login_required
def process_image_api():
    """å›¾åƒå¤„ç†API - æä¾›å¤šç§OpenCVå¤„ç†æ“ä½œ"""
    try:
        data = request.get_json()  # è§£æè¯·æ±‚æ•°æ®
        image_base64 = data.get('image')  # è·å–base64å›¾åƒ
        operation = data.get('operation')  # è·å–å¤„ç†æ“ä½œç±»å‹
        params = data.get('params', {})  # è·å–æ“ä½œå‚æ•°
        
        if not image_base64 or not operation:  # éªŒè¯å¿…è¦å‚æ•°
            return jsonify({"error": "ç¼ºå°‘å¿…è¦å‚æ•°"}), 400
        
        # è½¬æ¢å›¾åƒæ ¼å¼
        image = base64_to_opencv(image_base64)  # base64è½¬OpenCV
        if image is None:
            return jsonify({"error": "å›¾åƒæ ¼å¼é”™è¯¯"}), 400
        
        # æ‰§è¡Œå›¾åƒå¤„ç†
        processed_image = apply_image_processing(image, operation, params)
        
        # è½¬æ¢å›base64æ ¼å¼
        result_base64 = opencv_to_base64(processed_image)
        
        return jsonify({
            "success": True,
            "operation": operation,
            "image": result_base64,
            "params": params
        })
        
    except Exception as e:
        return jsonify({"error": f"å›¾åƒå¤„ç†å¤±è´¥: {str(e)}"}), 500

def apply_image_processing(image, operation, params=None):
    """åº”ç”¨æŒ‡å®šçš„å›¾åƒå¤„ç†æ“ä½œ"""
    if params is None:
        params = {}
    
    try:
        # ç°åº¦åŒ–å¤„ç†
        if operation == 'gray':
            return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # å½©è‰²è½¬ç°åº¦
        
        # é«˜æ–¯æ¨¡ç³Š
        elif operation == 'blur':
            kernel_size = params.get('kernel_size', 5)  # æ¨¡ç³Šæ ¸å¤§å°
            return cv2.GaussianBlur(image, (kernel_size, kernel_size), 0)
        
        # è¾¹ç¼˜æ£€æµ‹
        elif operation == 'edge':
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # å…ˆè½¬ç°åº¦
            low_threshold = params.get('low', 50)  # ä½é˜ˆå€¼
            high_threshold = params.get('high', 150)  # é«˜é˜ˆå€¼
            return cv2.Canny(gray, low_threshold, high_threshold)  # Cannyè¾¹ç¼˜æ£€æµ‹
        
        # äºŒå€¼åŒ–å¤„ç†
        elif operation == 'threshold':
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # è½¬ç°åº¦
            thresh_value = params.get('threshold', 127)  # é˜ˆå€¼
            max_value = params.get('max_value', 255)  # æœ€å¤§å€¼
            _, binary = cv2.threshold(gray, thresh_value, max_value, cv2.THRESH_BINARY)
            return binary
        
        # å›¾åƒç¼©æ”¾
        elif operation == 'resize':
            width = params.get('width', 500)  # ç›®æ ‡å®½åº¦
            height = params.get('height', 500)  # ç›®æ ‡é«˜åº¦
            return cv2.resize(image, (width, height))  # ç¼©æ”¾å›¾åƒ
        
        # å›¾åƒæ—‹è½¬
        elif operation == 'rotate':
            angle = params.get('angle', 90)  # æ—‹è½¬è§’åº¦
            height, width = image.shape[:2]  # è·å–å›¾åƒå°ºå¯¸
            center = (width // 2, height // 2)  # è®¡ç®—æ—‹è½¬ä¸­å¿ƒ
            rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)  # ç”Ÿæˆæ—‹è½¬çŸ©é˜µ
            return cv2.warpAffine(image, rotation_matrix, (width, height))  # åº”ç”¨æ—‹è½¬
        
        # å¯¹æ¯”åº¦å’Œäº®åº¦è°ƒæ•´
        elif operation == 'enhance':
            alpha = params.get('contrast', 1.2)  # å¯¹æ¯”åº¦ç³»æ•°
            beta = params.get('brightness', 10)  # äº®åº¦å¢é‡
            return cv2.convertScaleAbs(image, alpha=alpha, beta=beta)  # è°ƒæ•´å¯¹æ¯”åº¦å’Œäº®åº¦
        
        # é”åŒ–å¤„ç†
        elif operation == 'sharpen':
            kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])  # é”åŒ–å·ç§¯æ ¸
            return cv2.filter2D(image, -1, kernel)  # åº”ç”¨é”åŒ–æ»¤æ³¢
        
        # ç›´æ–¹å›¾å‡è¡¡åŒ–
        elif operation == 'equalize':
            if len(image.shape) == 3:  # å½©è‰²å›¾åƒ
                ycrcb = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)  # è½¬YCrCbè‰²å½©ç©ºé—´
                ycrcb[:,:,0] = cv2.equalizeHist(ycrcb[:,:,0])  # å¯¹Yé€šé“å‡è¡¡åŒ–
                return cv2.cvtColor(ycrcb, cv2.COLOR_YCrCb2BGR)  # è½¬å›BGR
            else:  # ç°åº¦å›¾åƒ
                return cv2.equalizeHist(image)  # ç›´æ¥å‡è¡¡åŒ–
        
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ“ä½œç±»å‹: {operation}")
            
    except Exception as e:
        print(f"å›¾åƒå¤„ç†é”™è¯¯: {e}")
        return image  # å¤„ç†å¤±è´¥è¿”å›åŸå›¾

def base64_to_opencv(base64_string):
    """base64å­—ç¬¦ä¸²è½¬OpenCVå›¾åƒ"""
    try:
        image_data = base64.b64decode(base64_string)  # base64è§£ç 
        nparr = np.frombuffer(image_data, np.uint8)  # è½¬numpyæ•°ç»„
        image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)  # è§£ç ä¸ºå›¾åƒ
        return image
    except Exception as e:
        print(f"Base64è½¬æ¢é”™è¯¯: {e}")
        return None

def opencv_to_base64(image):
    """OpenCVå›¾åƒè½¬base64å­—ç¬¦ä¸²"""
    try:
        _, buffer = cv2.imencode('.jpg', image)  # ç¼–ç ä¸ºJPEG
        image_base64 = base64.b64encode(buffer).decode('utf-8')  # base64ç¼–ç 
        return image_base64
    except Exception as e:
        print(f"å›¾åƒç¼–ç é”™è¯¯: {e}")
        return None
```

- **å®ç°**: åŸºäºOpenCVåº“å°è£…å¸¸ç”¨æ“ä½œï¼Œå¦‚ç°åº¦åŒ–ã€æ¨¡ç³Šã€è¾¹ç¼˜æ£€æµ‹ã€æ—‹è½¬ã€å¯¹æ¯”åº¦è°ƒæ•´ç­‰ã€‚
- **æ¥å£**: `/api/process-image`

3.5. AIå¼•æ“ç®¡ç†æ¨¡å—
- **åŠŸèƒ½**: è´Ÿè´£åˆå§‹åŒ–å’Œç®¡ç†æ‰€æœ‰AIè¯†åˆ«å¼•æ“çš„å®ä¾‹ã€‚

**æ ¸å¿ƒä»£ç å®ç°**ï¼š

```python
# å…¨å±€å˜é‡å®šä¹‰
ocr_engines = {}  # å…¨å±€å¼•æ“å­—å…¸ï¼Œå®ç°å•ä¾‹æ¨¡å¼
PADDLEOCR_AVAILABLE = True  # PaddleOCRå¯ç”¨æ€§æ ‡å¿—
HYPERLPR_AVAILABLE = True   # HyperLPR3å¯ç”¨æ€§æ ‡å¿—
TESSERACT_AVAILABLE = True  # Tesseractå¯ç”¨æ€§æ ‡å¿—
EASYOCR_AVAILABLE = True    # EasyOCRå¯ç”¨æ€§æ ‡å¿—

# å»¶è¿ŸåŠ è½½OCRå¼•æ“ï¼Œé¿å…å¯åŠ¨æ—¶çš„èµ„æºæ¶ˆè€—å’Œé”™è¯¯
def init_ocr_engines():
    """å»¶è¿Ÿåˆå§‹åŒ–OCRå¼•æ“ï¼Œé¿å…å¯åŠ¨æ—¶é”™è¯¯"""
    global ocr_engines, PADDLEOCR_AVAILABLE, EASYOCR_AVAILABLE, HYPERLPR_AVAILABLE
    
    # PaddleOCRåˆå§‹åŒ– - ç™¾åº¦å¼€æºé«˜ç²¾åº¦OCR
    if PADDLEOCR_AVAILABLE and PaddleOCR is not None and 'paddleocr' not in ocr_engines:
        try:
            # åˆ›å»ºPaddleOCRå®ä¾‹ï¼Œå…³é—­æ—¥å¿—è¾“å‡º
            ocr_engines['paddleocr'] = PaddleOCR(lang='ch', show_log=False)
            print("âœ… PaddleOCR åˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            print(f"âŒ PaddleOCR åˆå§‹åŒ–å¤±è´¥: {e}")
            PADDLEOCR_AVAILABLE = False  # æ ‡è®°ä¸ºä¸å¯ç”¨

    # HyperLPR3åˆå§‹åŒ– - ä¸“ä¸šè½¦ç‰Œè¯†åˆ«å¼•æ“
    if HYPERLPR_AVAILABLE and lpr3 is not None and 'hyperlpr3' not in ocr_engines:
        try:
            # åˆ›å»ºè½¦ç‰Œè¯†åˆ«å™¨å®ä¾‹
            ocr_engines['hyperlpr3'] = lpr3.LicensePlateCatcher()
            print("âœ… HyperLPR3 åˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            print(f"âŒ HyperLPR3 åˆå§‹åŒ–å¤±è´¥: {e}")
            HYPERLPR_AVAILABLE = False  # æ ‡è®°ä¸ºä¸å¯ç”¨

    # EasyOCRåˆå§‹åŒ– - è½»é‡çº§å¤šè¯­è¨€OCRï¼ˆä»…åœ¨éœ€è¦æ—¶åŠ è½½ï¼‰
    if EASYOCR_AVAILABLE and 'easyocr' not in ocr_engines:
        try:
            import easyocr
            # åˆ›å»ºEasyOCRå®ä¾‹ï¼Œæ”¯æŒä¸­æ–‡ç®€ä½“å’Œè‹±æ–‡ï¼Œä¸ä½¿ç”¨GPU
            ocr_engines['easyocr'] = easyocr.Reader(['ch_sim', 'en'], gpu=False)
            print("âœ… EasyOCR åˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            print(f"âŒ EasyOCR åˆå§‹åŒ–å¤±è´¥: {e}")
            EASYOCR_AVAILABLE = False  # æ ‡è®°ä¸ºä¸å¯ç”¨

# å¼•æ“çŠ¶æ€æ£€æŸ¥API
@app.route("/api/ocr-engines", methods=["GET"])
def get_ocr_engines():
    """è·å–æ‰€æœ‰OCRå¼•æ“çš„å¯ç”¨çŠ¶æ€"""
    init_ocr_engines()  # ç¡®ä¿å¼•æ“å·²å°è¯•åˆå§‹åŒ–
    
    engines = {}  # å¼•æ“çŠ¶æ€å­—å…¸
    
    # æ£€æŸ¥PaddleOCRçŠ¶æ€
    if PADDLEOCR_AVAILABLE and 'paddleocr' in ocr_engines:
        engines['paddleocr'] = {
            'name': 'PaddleOCR',
            'description': 'ç™¾åº¦å¼€æº OCRï¼Œæ”¯æŒä¸­è‹±æ–‡è¯†åˆ«',
            'version': 'latest',
            'available': True,
            'performance': 'high'  # æ€§èƒ½ç­‰çº§
        }
    else:
        engines['paddleocr'] = {
            'name': 'PaddleOCR',
            'description': 'ç™¾åº¦å¼€æº OCRï¼Œæ”¯æŒä¸­è‹±æ–‡è¯†åˆ«',
            'available': False,
            'error': 'PaddleOCR æœªå®‰è£…æˆ–åˆå§‹åŒ–å¤±è´¥'
        }
    
    # æ£€æŸ¥TesseractçŠ¶æ€
    if TESSERACT_AVAILABLE:
        engines['tesseract'] = {
            'name': 'Tesseract OCR',
            'description': 'ä¼ ç»Ÿ OCR å¼•æ“ï¼Œæ”¯æŒå¤šç§è¯­è¨€',
            'version': '4.x',
            'available': True,
            'performance': 'medium'
        }
    else:
        engines['tesseract'] = {
            'name': 'Tesseract OCR',
            'description': 'ä¼ ç»Ÿ OCR å¼•æ“ï¼Œæ”¯æŒå¤šç§è¯­è¨€',
            'available': False,
            'error': 'Tesseract æœªå®‰è£…'
        }
    
    # æ£€æŸ¥HyperLPR3çŠ¶æ€
    if HYPERLPR_AVAILABLE and 'hyperlpr3' in ocr_engines:
        engines['hyperlpr3'] = {
            'name': 'HyperLPR3',
            'description': 'ä¸“é—¨çš„è½¦ç‰Œè¯†åˆ«å¼•æ“',
            'version': '3.x',
            'available': True,
            'performance': 'specialized',  # ä¸“ç”¨æ€§èƒ½
            'specialty': 'license_plate'   # ä¸“ä¸šé¢†åŸŸ
        }
    else:
        engines['hyperlpr3'] = {
            'name': 'HyperLPR3',
            'description': 'ä¸“é—¨çš„è½¦ç‰Œè¯†åˆ«å¼•æ“',
            'available': False,
            'error': 'HyperLPR3 æœªå®‰è£…æˆ–åˆå§‹åŒ–å¤±è´¥'
        }
    
    # æ£€æŸ¥EasyOCRçŠ¶æ€
    if EASYOCR_AVAILABLE and 'easyocr' in ocr_engines:
        engines['easyocr'] = {
            'name': 'EasyOCR',
            'description': 'è½»é‡çº§å¤šè¯­è¨€OCRå¼•æ“',
            'version': 'latest',
            'available': True,
            'performance': 'medium',
            'languages': ['ch_sim', 'en']  # æ”¯æŒçš„è¯­è¨€
        }
    else:
        engines['easyocr'] = {
            'name': 'EasyOCR',
            'description': 'è½»é‡çº§å¤šè¯­è¨€OCRå¼•æ“',
            'available': False,
            'error': 'EasyOCR æœªå®‰è£…æˆ–åˆå§‹åŒ–å¤±è´¥'
        }
    
    # ç»Ÿè®¡ä¿¡æ¯
    total_engines = len(engines)
    available_engines = len([e for e in engines.values() if e['available']])
    
    return jsonify({
        "engines": engines,
        "total": total_engines,
        "available": available_engines,
        "availability_rate": f"{(available_engines/total_engines*100):.1f}%",
        "system_status": "healthy" if available_engines > 0 else "degraded"
    })

# å¼•æ“å¥åº·æ£€æŸ¥
def check_engine_health():
    """æ£€æŸ¥å¼•æ“å¥åº·çŠ¶æ€"""
    health_status = {}
    
    for engine_name, engine_instance in ocr_engines.items():
        try:
            # ç®€å•çš„å¥åº·æ£€æŸ¥ - å°è¯•è®¿é—®å¼•æ“å±æ€§
            if hasattr(engine_instance, '__class__'):
                health_status[engine_name] = {
                    'status': 'healthy',
                    'last_check': time.time()
                }
            else:
                health_status[engine_name] = {
                    'status': 'unhealthy',
                    'error': 'Engine instance invalid'
                }
        except Exception as e:
            health_status[engine_name] = {
                'status': 'error',
                'error': str(e)
            }
    
    return health_status
```

- **å®ç°**:
  - `init_ocr_engines()`å‡½æ•°ï¼šåœ¨åº”ç”¨å¯åŠ¨æ—¶æˆ–é¦–æ¬¡è¯·æ±‚æ—¶å»¶è¿ŸåŠ è½½å„ä¸ªOCRå¼•æ“ã€‚
  - å…¨å±€å˜é‡`ocr_engines`å­—å…¸ï¼šå­˜å‚¨å·²åˆå§‹åŒ–çš„å¼•æ“å®ä¾‹ï¼Œå®ç°å•ä¾‹æ¨¡å¼ï¼Œé¿å…é‡å¤åŠ è½½ã€‚
  - å¯ç”¨æ€§æ ‡å¿—ï¼šé€šè¿‡`HYPERLPR_AVAILABLE`, `PADDLEOCR_AVAILABLE`ç­‰å¸ƒå°”å˜é‡ç®¡ç†å¼•æ“çš„å¯ç”¨çŠ¶æ€ã€‚

================================================================================
4. æ¥å£è®¾è®¡ (API)
================================================================================

- **POST /api/ocr-simple**
  - **æè¿°**: æ ¸å¿ƒçš„å›¾åƒè¯†åˆ«æ¥å£ã€‚
  - **è¯·æ±‚ä½“ (JSON)**:
    ```json
    {
      "image": "<base64_encoded_image_string>",
      "engine": "auto" | "hyperlpr3" | "paddleocr" | "easyocr" | "tesseract"
    }
    ```
  - **å“åº”ä½“ (JSON) - æˆåŠŸ**:
    ```json
    {
      "success": true,
      "engine": "hyperlpr3",
      "text": "æ´¥A88888",
      "confidence": 0.95,
      "results": { ... }, // å¼•æ“åŸå§‹è¯¦ç»†ç»“æœ
      "image_quality": { ... } // å›¾åƒè´¨é‡åˆ†æç»“æœ
    }
    ```
  - **å“åº”ä½“ (JSON) - å¤±è´¥**:
    ```json
    {
      "success": false,
      "error": "æ‰€æœ‰OCRå¼•æ“è¯†åˆ«å¤±è´¥",
      "suggestion": "...",
      "available_engines": { ... }
    }
    ```

- **POST /api/process-image**
  - **æè¿°**: åº”ç”¨å›¾åƒå¤„ç†æ“ä½œã€‚
  - **è¯·æ±‚ä½“ (JSON)**:
    ```json
    {
      "image": "<base64_encoded_image_string>",
      "operation": "grayscale" | "blur" | "canny" | ...
    }
    ```
  - **å“åº”ä½“ (JSON)**:
    ```json
    {
      "success": true,
      "image": "<base64_encoded_processed_image_string>"
    }
    ```

- **GET /api/ocr-engines**
  - **æè¿°**: è·å–å½“å‰æ‰€æœ‰OCRå¼•æ“çš„çŠ¶æ€ã€‚
  - **å“åº”ä½“ (JSON)**:
    ```json
    {
      "hyperlpr3": {"name": "HyperLPR3", "available": true},
      "paddleocr": {"name": "PaddleOCR", "available": true},
      ...
    }
    ```

================================================================================
5. å‰ç«¯è®¾è®¡
================================================================================

5.1. é¡µé¢ç»“æ„
- **`ocr.html`**: ä¸»åŠŸèƒ½é¡µé¢ï¼Œé‡‡ç”¨`<header>`, `<nav>`, `<main>`, `<footer>`è¯­ä¹‰åŒ–å¸ƒå±€ã€‚
  - **`<nav class="tab-nav">`**: åŠŸèƒ½åŒºåˆ‡æ¢æ ‡ç­¾ï¼ˆGemini, OCR, è½¦ç‰Œ, å›¾åƒå¤„ç†ï¼‰ã€‚
  - **`<main>`**: åŒ…å«å„ä¸ªåŠŸèƒ½åŒºçš„`<div class="tab-content">`ã€‚
  - **æ¯ä¸ªåŠŸèƒ½åŒº**: åŒ…å«å›¾ç‰‡ä¸Šä¼ åŒºã€æ“ä½œåŒºå’Œç»“æœæ˜¾ç¤ºåŒºã€‚

5.2. æ ¸å¿ƒJavaScripté€»è¾‘ (`ocr-main.js`)

**æ ¸å¿ƒä»£ç å®ç°**ï¼š

```javascript
// å…¨å±€çŠ¶æ€ç®¡ç†
let currentImages = {
  gemini: null,    // Gemini AIåˆ†æå›¾ç‰‡
  ocr: null,       // é€šç”¨OCRè¯†åˆ«å›¾ç‰‡
  plate: null,     // è½¦ç‰Œè¯†åˆ«å›¾ç‰‡
  process: null    // å›¾åƒå¤„ç†å›¾ç‰‡
};
let enginesStatus = {};  // OCRå¼•æ“çŠ¶æ€ç¼“å­˜
let recognitionHistory = [];  // è¯†åˆ«å†å²è®°å½•

// é«˜çº§Toasté€šçŸ¥ç³»ç»Ÿ - æä¾›ä¸°å¯Œçš„ç”¨æˆ·åé¦ˆ
function showToast(message, type = 'info', options = {}) {
  const {
    duration = getDefaultDuration(type),  // æ ¹æ®æ¶ˆæ¯ç±»å‹è®¾ç½®æŒç»­æ—¶é—´
    showProgressBar = false,              // æ˜¯å¦æ˜¾ç¤ºè¿›åº¦æ¡
    position = 'top-right',               // æ˜¾ç¤ºä½ç½®
    closable = true,                      // æ˜¯å¦å¯æ‰‹åŠ¨å…³é—­
    icon = getDefaultIcon(type)           // æ¶ˆæ¯å›¾æ ‡
  } = options;

  // åˆ›å»ºToastå®¹å™¨å…ƒç´ 
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;  // è®¾ç½®CSSç±»å
  
  // åŠ¨æ€æ ·å¼è®¾ç½®
  toast.style.cssText = `
    position: fixed;                      /* å›ºå®šå®šä½ */
    ${getPositionStyles(position)}        /* æ ¹æ®ä½ç½®è®¾ç½®åæ ‡ */
    background: ${getBackgroundColor(type)};  /* èƒŒæ™¯è‰² */
    color: ${getTextColor(type)};         /* æ–‡å­—é¢œè‰² */
    padding: 16px 20px;                   /* å†…è¾¹è· */
    border-radius: 12px;                  /* åœ†è§’ */
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);  /* é˜´å½±æ•ˆæœ */
    backdrop-filter: blur(10px);          /* èƒŒæ™¯æ¨¡ç³Š */
    z-index: 10003;                       /* å±‚çº§ */
    opacity: 0;                           /* åˆå§‹é€æ˜ */
    transform: translateX(${position.includes('right') ? '100%' : '-100%'}) scale(0.8);  /* åˆå§‹ä½ç½®å’Œç¼©æ”¾ */
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);  /* ç¼“åŠ¨åŠ¨ç”» */
  `;

  // åˆ›å»ºæ¶ˆæ¯å†…å®¹ç»“æ„
  const content = document.createElement('div');
  content.style.display = 'flex';
  content.style.alignItems = 'flex-start';
  content.style.gap = '12px';

  // æ·»åŠ å›¾æ ‡
  const iconElement = document.createElement('div');
  iconElement.innerHTML = icon;
  iconElement.style.fontSize = '18px';
  content.appendChild(iconElement);

  // æ·»åŠ æ¶ˆæ¯æ–‡æœ¬
  const messageText = document.createElement('div');
  messageText.textContent = message;
  messageText.style.fontWeight = '500';
  content.appendChild(messageText);

  toast.appendChild(content);
  document.body.appendChild(toast);  // æ·»åŠ åˆ°é¡µé¢

  // æ˜¾ç¤ºåŠ¨ç”»
  setTimeout(() => {
    toast.style.opacity = '1';        // å®Œå…¨ä¸é€æ˜
    toast.style.transform = 'translateX(0) scale(1)';  // å½’ä½å¹¶æ¢å¤æ­£å¸¸å¤§å°
  }, 10);

  // è‡ªåŠ¨ç§»é™¤
  if (duration > 0) {
    setTimeout(() => removeToast(toast), duration);
  }
}

// OCRæ ‡ç­¾é¡µåˆå§‹åŒ– - æ¨¡å—åŒ–è®¾è®¡
function initializeOCRTab() {
  // è·å–DOMå…ƒç´ 
  const ocrUpload = document.getElementById('ocr-upload');      // æ–‡ä»¶ä¸Šä¼ input
  const ocrPreview = document.getElementById('ocr-preview');    // å›¾ç‰‡é¢„è§ˆåŒºåŸŸ
  const ocrRecognize = document.getElementById('ocr-recognize'); // è¯†åˆ«æŒ‰é’®
  const ocrResult = document.getElementById('ocr-result');      // ç»“æœæ˜¾ç¤ºåŒºåŸŸ
  
  // æ–‡ä»¶ä¸Šä¼ å¤„ç† - æ”¯æŒå¤šç§éªŒè¯
  ocrUpload.addEventListener('change', async (e) => {
    const file = e.target.files[0];  // è·å–é€‰æ‹©çš„æ–‡ä»¶
    if (file) {
      try {
        showProgress(20);  // æ˜¾ç¤ºåˆå§‹è¿›åº¦
        
        // æ–‡ä»¶å¤§å°éªŒè¯
        if (file.size > 16 * 1024 * 1024) {  // 16MBé™åˆ¶
          throw new Error('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡16MB');
        }
        
        // æ–‡ä»¶ç±»å‹éªŒè¯
        if (!file.type.startsWith('image/')) {
          throw new Error('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
        }
        
        showProgress(40);  // æ›´æ–°è¿›åº¦
        
        // å¼‚æ­¥æ–‡ä»¶è½¬æ¢
        const base64 = await fileToBase64(file);  // è½¬æ¢ä¸ºbase64
        currentImages.ocr = base64;               // ä¿å­˜åˆ°å…¨å±€çŠ¶æ€
        
        showProgress(70);  // ç»§ç»­æ›´æ–°è¿›åº¦
        
        // åˆ›å»ºé«˜çº§é¢„è§ˆ - å¢å¼ºç”¨æˆ·ä½“éªŒ
        createAdvancedImagePreview(ocrPreview, base64, `OCRå›¾ç‰‡: ${file.name}`);
        ocrRecognize.disabled = false;  // å¯ç”¨è¯†åˆ«æŒ‰é’®
        
        showProgress(100);  // å®Œæˆè¿›åº¦
        
        // æˆåŠŸåé¦ˆ
        showToast(`å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼š${file.name} (${(file.size / 1024).toFixed(1)}KB)`, 'success');
        
        // æ·»åŠ åˆ°å†å²è®°å½•
        addToHistory('upload', { 
          filename: file.name, 
          type: file.type, 
          size: file.size,
          tab: 'ocr'
        });
        
        // è‡ªåŠ¨åˆ†æå›¾ç‰‡å±æ€§
        analyzeImageProperties(file, base64);
        
      } catch (error) {
        showProgress(100);  // å®Œæˆè¿›åº¦æ˜¾ç¤º
        showToast('å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼š' + error.message, 'error');
      }
    }
  });
  
  // OCRè¯†åˆ«å¤„ç† - å¼‚æ­¥æ“ä½œ
  ocrRecognize.addEventListener('click', async () => {
    if (!currentImages.ocr) {  // éªŒè¯å›¾ç‰‡æ˜¯å¦å·²ä¸Šä¼ 
      showToast('è¯·å…ˆä¸Šä¼ å›¾ç‰‡', 'error');
      return;
    }
    
    // è·å–ç”¨æˆ·é€‰æ‹©çš„å¼•æ“
    const selectedEngine = document.querySelector('input[name="ocr-engine"]:checked').value;
    const extractPlate = document.getElementById('extract-plate-checkbox')?.checked || false;
    
    // éªŒè¯å¼•æ“å¯ç”¨æ€§
    if (!enginesStatus[selectedEngine] || !enginesStatus[selectedEngine].available) {
      showToast(`${enginesStatus[selectedEngine]?.name || selectedEngine} å¼•æ“ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥æ˜¯å¦å·²æ­£ç¡®å®‰è£…`, 'error');
      return;
    }
    
    // åˆ›å»ºè¯†åˆ«è¿›åº¦æ˜¾ç¤º
    const progressContainer = createProgressContainer(ocrResult, 'æ­£åœ¨è¯†åˆ«æ–‡å­—...');
    
    // è¿›åº¦æ¨¡æ‹Ÿ
    const startTime = Date.now();
    let progressInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(90, (elapsed / 5000) * 100);  // 5ç§’å†…åˆ°è¾¾90%
      showProgress(progress);
    }, 100);
    
    try {
      // å‘é€è¯†åˆ«è¯·æ±‚
      const response = await fetch('/api/ocr-simple', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          image: currentImages.ocr,  // base64å›¾åƒæ•°æ®
          engine: selectedEngine,    // é€‰æ‹©çš„OCRå¼•æ“
          extract_plate: extractPlate  // æ˜¯å¦å¯ç”¨è½¦ç‰Œæå–
        })
      });
      
      clearInterval(progressInterval);  // æ¸…é™¤è¿›åº¦æ›´æ–°
      showProgress(100);  // è®¾ç½®ä¸ºå®ŒæˆçŠ¶æ€
      
      const data = await response.json();  // è§£æå“åº”
      
      if (data.success) {
        // æ„å»ºç»“æœæ˜¾ç¤ºHTML
        const resultHtml = `
          <div class="ocr-result-summary">
            <h4><i class="fas fa-check-circle"></i> OCRè¯†åˆ«ç»“æœ (${data.engine})</h4>
            <div class="text-result">
              <strong>è¯†åˆ«æ–‡æœ¬:</strong><br>
              <span class="recognized-text">${data.text}</span>
            </div>
            <div class="confidence-info">
              <strong>ç½®ä¿¡åº¦:</strong> 
              <span class="confidence ${data.confidence > 0.7 ? 'high' : data.confidence > 0.4 ? 'medium' : 'low'}">
                ${(data.confidence * 100).toFixed(1)}%
              </span>
            </div>
            ${data.image_quality ? `
              <div class="quality-info">
                <strong>å›¾åƒè´¨é‡:</strong> ${data.image_quality.quality_score}/100
                ${data.image_quality.suggestions && data.image_quality.suggestions.length > 0 ? 
                  `<div class="suggestions">ğŸ’¡ ${data.image_quality.suggestions.join('; ')}</div>` : ''}
              </div>
            ` : ''}
            ${data.warning ? `<div class="warning"><i class="fas fa-exclamation-triangle"></i> ${data.warning}</div>` : ''}
          </div>
        `;
        
        ocrResult.innerHTML = resultHtml;  // æ˜¾ç¤ºç»“æœ
        ocrResult.className = 'result-box success';  // è®¾ç½®æˆåŠŸæ ·å¼
        
        // æˆåŠŸåé¦ˆ
        showToast('OCRè¯†åˆ«å®Œæˆï¼', 'success');
        
        // æ·»åŠ åˆ°å†å²è®°å½•
        addToHistory('recognition', {
          engine: data.engine,
          text: data.text,
          confidence: data.confidence,
          timestamp: new Date().toISOString()
        });
        
      } else {
        throw new Error(data.error || 'è¯†åˆ«å¤±è´¥');
      }
      
    } catch (error) {
      clearInterval(progressInterval);  // æ¸…é™¤è¿›åº¦æ›´æ–°
      ocrResult.textContent = 'è¯†åˆ«å¤±è´¥ï¼š' + error.message;  // æ˜¾ç¤ºé”™è¯¯
      ocrResult.className = 'result-box error';  // è®¾ç½®é”™è¯¯æ ·å¼
      showToast('OCR è¯†åˆ«å¤±è´¥ï¼š' + error.message, 'error');
    }
  });
  
  // å¼•æ“é€‰æ‹©å˜åŒ–å¤„ç†
  document.querySelectorAll('input[name="ocr-engine"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      const engineKey = e.target.value;
      const engine = enginesStatus[engineKey];
      
      if (engine) {
        showToast(`å·²é€‰æ‹© ${engine.name} å¼•æ“`, 'info');
        
        // æ˜¾ç¤ºå¼•æ“ç‰¹æ€§æç¤º
        const tips = {
          'paddleocr': 'é€‚åˆä¸­è‹±æ–‡æ··åˆè¯†åˆ«ï¼Œè¯†åˆ«ç²¾åº¦é«˜',
          'tesseract': 'æ”¯æŒå¤šç§è¯­è¨€ï¼Œé€‚åˆæ ‡å‡†å°åˆ·ä½“',
          'hyperlpr3': 'ä¸“ä¸šè½¦ç‰Œè¯†åˆ«å¼•æ“'
        };
        
        if (tips[engineKey]) {
          setTimeout(() => {
            showToast(tips[engineKey], 'info');
          }, 1000);
        }
      }
    });
  });
}

// è½¦ç‰Œè¯†åˆ«æ ‡ç­¾é¡µåˆå§‹åŒ–
function initializePlateTab() {
  const plateUpload = document.getElementById('plate-upload');
  const platePreview = document.getElementById('plate-preview');
  const plateRecognize = document.getElementById('plate-recognize');
  const plateResult = document.getElementById('plate-result');
  
  // è½¦è¾†å›¾ç‰‡ä¸Šä¼ å¤„ç†
  plateUpload.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (file) {
      try {
        const base64 = await fileToBase64(file);  // è½¬æ¢ä¸ºbase64
        currentImages.plate = base64;             // ä¿å­˜åˆ°å…¨å±€çŠ¶æ€
        
        // æ˜¾ç¤ºé¢„è§ˆ
        platePreview.innerHTML = `<img src="data:image/jpeg;base64,${base64}" alt="ä¸Šä¼ çš„è½¦è¾†å›¾ç‰‡">`;
        plateRecognize.disabled = false;  // å¯ç”¨è¯†åˆ«æŒ‰é’®
        
        showToast('è½¦è¾†å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼', 'success');
      } catch (error) {
        showToast('å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼š' + error.message, 'error');
      }
    }
  });
  
  // è½¦ç‰Œè¯†åˆ«å¤„ç†
  plateRecognize.addEventListener('click', async () => {
    if (!currentImages.plate) {
      showToast('è¯·å…ˆä¸Šä¼ è½¦è¾†å›¾ç‰‡', 'error');
      return;
    }
    
    // æ£€æŸ¥HyperLPR3å¼•æ“å¯ç”¨æ€§
    if (!enginesStatus.hyperlpr3 || !enginesStatus.hyperlpr3.available) {
      showToast('HyperLPR3 å¼•æ“ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥æ˜¯å¦å·²æ­£ç¡®å®‰è£…', 'error');
      return;
    }
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    plateResult.innerHTML = '<div class="loading-spinner"></div>æ­£åœ¨è¯†åˆ«è½¦ç‰Œ...';
    plateResult.className = 'result-box loading';
    
    try {
      // å‘é€è½¦ç‰Œè¯†åˆ«è¯·æ±‚
      const response = await fetch('/api/ocr-simple', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          image: currentImages.plate,  // è½¦è¾†å›¾ç‰‡æ•°æ®
          engine: 'hyperlpr3'          // ä½¿ç”¨ä¸“ä¸šè½¦ç‰Œè¯†åˆ«å¼•æ“
        })
      });
      
      const data = await response.json();
      
      if (data.success && data.results.plates) {
        displayPlateResults(data.results.plates, plateResult);  // æ˜¾ç¤ºè½¦ç‰Œç»“æœ
        plateResult.className = 'result-box success';
      } else {
        throw new Error(data.error || 'æœªè¯†åˆ«åˆ°è½¦ç‰Œ');
      }
      
    } catch (error) {
      plateResult.textContent = 'è¯†åˆ«å¤±è´¥ï¼š' + error.message;
      plateResult.className = 'result-box error';
      showToast('è½¦ç‰Œè¯†åˆ«å¤±è´¥ï¼š' + error.message, 'error');
    }
  });
}

// å·¥å…·å‡½æ•°ï¼šæ–‡ä»¶è½¬base64
async function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();  // åˆ›å»ºæ–‡ä»¶è¯»å–å™¨
    reader.readAsDataURL(file);       // è¯»å–æ–‡ä»¶ä¸ºDataURL
    reader.onload = () => resolve(reader.result.split(',')[1]);  // æå–base64éƒ¨åˆ†
    reader.onerror = error => reject(error);  // å¤„ç†é”™è¯¯
  });
}

// è·å–å¼•æ“çŠ¶æ€
async function loadEnginesStatus() {
  try {
    const response = await fetch('/api/ocr-engines');  // è¯·æ±‚å¼•æ“çŠ¶æ€
    const data = await response.json();
    enginesStatus = data.engines;  // æ›´æ–°å…¨å±€çŠ¶æ€
    
    // æ ¹æ®å¼•æ“çŠ¶æ€æ›´æ–°UI
    updateEngineStatusUI();
  } catch (error) {
    console.error('æ— æ³•è·å–å¼•æ“çŠ¶æ€:', error);
    showToast('æ— æ³•è·å–OCRå¼•æ“çŠ¶æ€', 'warning');
  }
}

// é¡µé¢åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', () => {
  initializeOCRTab();         // åˆå§‹åŒ–OCRæ ‡ç­¾é¡µ
  initializePlateTab();       // åˆå§‹åŒ–è½¦ç‰Œè¯†åˆ«æ ‡ç­¾é¡µ
  initializeProcessTab();     // åˆå§‹åŒ–å›¾åƒå¤„ç†æ ‡ç­¾é¡µ
  loadEnginesStatus();        // åŠ è½½å¼•æ“çŠ¶æ€
  
  console.log('ğŸš€ å¤©æ´¥ä»çˆ±å­¦é™¢è½¦ç‰Œè¯†åˆ«ç³»ç»Ÿå‰ç«¯åˆå§‹åŒ–å®Œæˆ');
});
```

- **æ¨¡å—åŒ–**: ä½¿ç”¨`initialize`ç³»åˆ—å‡½æ•°ï¼ˆå¦‚`initializeOCRTab`, `initializePlateTab`ï¼‰åˆ†åˆ«åˆå§‹åŒ–æ¯ä¸ªåŠŸèƒ½æ ‡ç­¾é¡µçš„äº‹ä»¶ç›‘å¬å’Œé€»è¾‘ã€‚
- **çŠ¶æ€ç®¡ç†**:
  - `currentImages`: å¯¹è±¡ï¼Œå­˜å‚¨å„ä¸ªåŠŸèƒ½åŒºå½“å‰ä¸Šä¼ çš„å›¾ç‰‡çš„Base64ç¼–ç ã€‚
  - `enginesStatus`: å¯¹è±¡ï¼Œä»`/api/ocr-engines`è·å–å¹¶å­˜å‚¨å¼•æ“çš„å¯ç”¨çŠ¶æ€ã€‚
- **å¼‚æ­¥é€šä¿¡**: ä½¿ç”¨`fetch` APIä¸åç«¯è¿›è¡Œå¼‚æ­¥JSONæ•°æ®äº¤æ¢ã€‚
- **ç”¨æˆ·åé¦ˆ**:
  - **`showToast()`**: æ˜¾ç¤ºçŸ­æš‚çš„æ¶ˆæ¯æç¤ºï¼ˆæˆåŠŸã€å¤±è´¥ã€ä¿¡æ¯ï¼‰ã€‚
  - **åŠ è½½çŠ¶æ€**: åœ¨APIè¯·æ±‚æœŸé—´ï¼Œæ˜¾ç¤ºåŠ è½½åŠ¨ç”»ï¼ˆspinnerï¼‰ï¼Œå¹¶ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤æäº¤ã€‚
  - **ç»“æœå±•ç¤º**: åŠ¨æ€ç”ŸæˆHTMLæ¥å±•ç¤ºè¯†åˆ«ç»“æœï¼Œå¹¶æ ¹æ®ç»“æœç±»å‹ï¼ˆæˆåŠŸ/å¤±è´¥ï¼‰åº”ç”¨ä¸åŒæ ·å¼ã€‚

5.3. æ ·å¼è®¾è®¡ (`ocr-style.css`)
- **ç°ä»£å¸ƒå±€**: å¹¿æ³›ä½¿ç”¨Flexboxå’ŒGridè¿›è¡Œé¡µé¢å¸ƒå±€ï¼Œå®ç°çµæ´»æ€§å’Œå“åº”å¼ã€‚
- **è§†è§‰é£æ ¼**: ç®€æ´ã€ä¸“ä¸šçš„ç§‘æŠ€æ„Ÿé£æ ¼ï¼Œä»¥æ·±è“å’Œç´«è‰²æ¸å˜ä¸ºä¸»è‰²è°ƒã€‚
- **äº¤äº’åŠ¨æ•ˆ**: ä¸ºæŒ‰é’®ã€å¡ç‰‡ç­‰å…ƒç´ æ·»åŠ å¹³æ»‘çš„CSSè¿‡æ¸¡å’ŒåŠ¨ç”»æ•ˆæœï¼Œæå‡ç”¨æˆ·ä½“éªŒã€‚

================================================================================
6. éƒ¨ç½²è®¾è®¡
================================================================================

- **å¼€å‘ç¯å¢ƒ**: ä½¿ç”¨Flaskå†…ç½®çš„å¼€å‘æœåŠ¡å™¨ï¼Œå¼€å¯`debug=True`æ¨¡å¼ã€‚
- **ç”Ÿäº§ç¯å¢ƒ**:
  - **åº”ç”¨æœåŠ¡å™¨**: ä½¿ç”¨`Gunicorn`ä½œä¸ºWSGIæœåŠ¡å™¨æ¥è¿è¡ŒFlaskåº”ç”¨ï¼Œä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½å’Œå¹¶å‘å¤„ç†èƒ½åŠ›ã€‚
  - **WebæœåŠ¡å™¨**: åœ¨`Gunicorn`å‰éƒ¨ç½²`Nginx`ä½œä¸ºåå‘ä»£ç†ã€‚`Nginx`è´Ÿè´£å¤„ç†é™æ€æ–‡ä»¶è¯·æ±‚ã€è´Ÿè½½å‡è¡¡å’ŒHTTPSåŠ å¯†ï¼Œå¹¶å°†åŠ¨æ€è¯·æ±‚è½¬å‘ç»™`Gunicorn`ã€‚
  - **è¿›ç¨‹ç®¡ç†**: ä½¿ç”¨`systemd`æˆ–`Supervisor`æ¥ç®¡ç†`Gunicorn`è¿›ç¨‹ï¼Œç¡®ä¿å…¶ç¨³å®šè¿è¡Œå’Œå¼€æœºè‡ªå¯ã€‚

================================================================================
æ–‡æ¡£ç»“æŸ
================================================================================
